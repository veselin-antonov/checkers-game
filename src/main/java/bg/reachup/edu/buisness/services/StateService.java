package bg.reachup.edu.buisness.services;

import bg.reachup.edu.buisness.Pair;
import bg.reachup.edu.buisness.exceptions.state.IllegalActionException;
import bg.reachup.edu.buisness.exceptions.state.NoPieceAtCoordinatesException;
import bg.reachup.edu.buisness.exceptions.state.OpponentPieceException;
import bg.reachup.edu.data.entities.*;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

@Service
public class StateService {


    public List<State> getChildren(State state) {
        List<State> children = state.getChildren();
        if (children != null) {
            return children;
        }
        List<State> newChildren = new LinkedList<>();
        List<Piece> pieces = state.isPlayer1Turn() ? state.getWhitePieces() : state.getBlackPieces();
        pieces.forEach(piece -> newChildren.addAll(captureWithPiece(piece, state)));
        newChildren.removeIf(Objects::isNull);
        if (newChildren.isEmpty()) {
            pieces.forEach(piece -> newChildren.addAll(movePiece(piece, state)));
        }
        newChildren.removeIf(Objects::isNull);
        state.setChildren(newChildren);
        return newChildren;
    }

    /*
     * Record describing a move action. Contains the information, needed to perform the action:
     * - the direction in which the piece will be moved
     * - the offset by which the piece will be moved
     * - the predicate, testing if the move is possible.
     * */
    private record MoveAction(
            Direction moveDirection,
            Coordinates positionOffset,
            Predicate<Piece> predicate
    ) {
    }

    /*
     * Array consisting of all the possible ways to move a piece in the game
     * The elements are sorted by their ordinal value, so that every element's
     * ordinal value matches their index in the array, giving you direct access
     * when searching by direction.
     * */
    private final MoveAction[] possibleMoveActions = {
            new MoveAction(
                    Direction.UP_LEFT,
                    new Coordinates(-1, -1),
                    Piece::isWhite
            ),
            new MoveAction(
                    Direction.UP_RIGHT,
                    new Coordinates(-1, 1),
                    Piece::isWhite
            ),
            new MoveAction(
                    Direction.DOWN_LEFT,
                    new Coordinates(1, -1),
                    Piece::isBlack
            ),
            new MoveAction(
                    Direction.DOWN_RIGHT,
                    new Coordinates(1, 1),
                    Piece::isBlack
            )
    };

    /*
     * Generates a list of the states generated by the tryMove() method for each of the possible move actions.
     * */
    private List<State> movePiece(Piece piece, State state) {
        List<State> newStates = new LinkedList<>();
        for (MoveAction moveAction : possibleMoveActions) {
            tryMove(piece, moveAction, state).ifPresent(newStates::add);
        }
        return newStates;
    }

    /*
     * The actual logic of moving a piece.
     * The method generates the new coordinates when the given offset is applied and then checks if these coordinates are valid:
     * - inside the board
     * - the new position is empty
     * - the piece type is allowed to move in that direction
     * - the given predicate returns true for the given piece.
     * */
    private Optional<State> tryMove(
            Piece piece, MoveAction action, State state
    ) {
        Coordinates positionOffset = action.positionOffset;
        Predicate<Piece> predicate = action.predicate;

        Coordinates newCoordinates = piece.getCoordinates().modified(positionOffset.row(), positionOffset.column());
        if ((piece.isQueen() || predicate.test(piece))
                && state.getBoard().isWithin(newCoordinates)
                && state.getBoard().isFree(newCoordinates)
        ) {
            Board newBoard = state.getBoard().movePiece(piece.getCoordinates(), newCoordinates);
            return Optional.of(new State(newBoard, !state.isPlayer1Turn(), new Action(ActionType.MOVE, action.moveDirection(), piece.getCoordinates(), null)));
        }
        return Optional.empty();
    }

    /*
     * Record describing a capture action. Contains the information, needed to perform the action:
     * the direction in which the piece will be capturing
     * the offset to calculate the position of the opponent piece
     * the offset by which the piece will be moved
     * the predicate, testing if the capture is possible.
     * */
    private record CaptureAction(
            Direction captureDirection,
            Coordinates opponentOffset,
            Coordinates newPositionOffset,
            Predicate<Piece> predicate
    ) {
    }

    /*
     * Array consisting of all the possible ways to capture a piece in the game.
     * The elements are sorted by their ordinal value, so that every element's
     * ordinal value matches their index in the array, giving you direct access
     * when searching by direction.
     */
    private final CaptureAction[] possibleCaptureActions = {
            new CaptureAction(
                    Direction.UP_LEFT,
                    new Coordinates(-1, -1),
                    new Coordinates(-2, -2),
                    Piece::isWhite
            ),
            new CaptureAction(
                    Direction.UP_RIGHT,
                    new Coordinates(-1, 1),
                    new Coordinates(-2, 2),
                    Piece::isWhite
            ),
            new CaptureAction(
                    Direction.DOWN_LEFT,
                    new Coordinates(1, -1),
                    new Coordinates(2, -2),
                    Piece::isBlack
            ),
            new CaptureAction(
                    Direction.DOWN_RIGHT,
                    new Coordinates(1, 1),
                    new Coordinates(2, 2),
                    Piece::isBlack
            )
    };

    /*
     * Generates the states for capturing in all possible directions with the specified piece.
     * A list of the states with the largest capture streak are returned.
     */
    private List<State> captureWithPiece(Piece piece, State state) {
        List<Pair<Integer, List<State>>> biggestCaptures = new LinkedList<>();
        for (CaptureAction captureAction : possibleCaptureActions) {
            Pair<Integer, List<State>> captureStates = tryCaptureWith(piece, captureAction, state, true);
            if (!captureStates.value2().isEmpty()) {
                biggestCaptures.add(captureStates);
            }
        }
        if (biggestCaptures.isEmpty()) {
            return List.of();
        }
        int maxCaptureStreak = biggestCaptures.stream()
                .mapToInt(Pair::value1)
                .max()
                .orElse(-1);
        return biggestCaptures.stream()
                .filter(pair -> pair.value1() == maxCaptureStreak)
                .map(Pair::value2)
                .flatMap(List::stream)
                .toList();
    }

    /*
     * Finds the state/states with the largest capture streak in the given direction. The method returns a
     * pair consisting of the number of consecutive captures and the corresponding list of states with
     * such streak. All the states are put in a stream, and collected in a TreeMap grouped by their capture
     * streak. The last entry (states with the largest streak) is returned as a pair object.
     */
    private Pair<Integer, List<State>> tryCaptureWith(
            Piece piece,
            CaptureAction action,
            State state,
            boolean chainCapture
    ) {
        Board board = state.getBoard();
        Coordinates opponentOffset = action.opponentOffset;
        Coordinates newPositionOffset = action.newPositionOffset;
        Predicate<Piece> predicate = action.predicate;

        Coordinates oldPos = piece.getCoordinates();
        Coordinates opponentPos = oldPos.modified(opponentOffset.row(), opponentOffset.column());
        Coordinates newPos = oldPos.modified(newPositionOffset.row(), newPositionOffset.column());

        if ((!predicate.test(piece) && !piece.isQueen())
                || !board.isWithin(newPos)
                || !board.isFree(newPos)
        ) {
            return new Pair<>(state.getCaptureStreak(), List.of());
        }
        Optional<Piece> toCapture = board.getAt(opponentPos);
        if (toCapture.isEmpty() || !toCapture.get().isOpponent(piece)) {
            return new Pair<>(state.getCaptureStreak(), List.of());
        }
        Board newBoard = board.movePiece(oldPos, newPos);
        newBoard.removeAt(toCapture.get().getCoordinates());
        State newState = new State(
                newBoard,
                state.isPlayer1Turn(),
                newBoard.getAt(newPos).get(),
                state.getCaptureStreak() + 1,
                state.getCaptureStreak() > 0 && piece.equals(state.getAttacker()) ?
                        state.getOriginAction() :
                        new Action(ActionType.CAPTURE, action.captureDirection(), oldPos, null)
        );

        if (!chainCapture) {
            return new Pair<>(newState.getCaptureStreak(), List.of(newState));
        }

        TreeMap<Integer, List<State>> bestCaptureStreakStates = captureWithPiece(newState.getAttacker(), newState).stream()
                .collect(Collectors.groupingBy(State::getCaptureStreak, TreeMap::new, Collectors.toList()));
        if (bestCaptureStreakStates.isEmpty()) {
            newState.setPlayer1Turn(!newState.isPlayer1Turn());
            return new Pair<>(newState.getCaptureStreak(), List.of(newState));
        } else {
            return new Pair<>(bestCaptureStreakStates.lastEntry().getKey(), bestCaptureStreakStates.lastEntry().getValue());
        }
    }

    /*
     * Returns the state of the game after executing the specified action.
     */
    // TODO: 22.2.2023 At end of turn -> switch player if necessary, set final state
    public State executeAction(Action action, State state) {
        Piece piece = state.getBoard().getAt(action.piecePosition()).orElseThrow(NoPieceAtCoordinatesException::new);

        if ((state.isPlayer1Turn() && piece.isBlack()) || (!state.isPlayer1Turn() && piece.isWhite())) {
            throw new OpponentPieceException();
        }

        State newState;
        List<State> possibleCaptures = captureWithPiece(piece, state);
        if ((possibleCaptures.isEmpty() && action.actionType() == ActionType.CAPTURE)
                || (!possibleCaptures.isEmpty() && action.actionType() == ActionType.MOVE)) {
            throw new IllegalActionException();
        } else if (possibleCaptures.isEmpty() && action.actionType() == ActionType.MOVE) {
            MoveAction moveAction = possibleMoveActions[action.direction().ordinal()];
            newState = tryMove(piece, moveAction, state).orElseThrow(IllegalActionException::new);
            newState.setPlayer1Turn(!state.isPlayer1Turn());
            newState.setId(state.getId());
        } else {
            possibleCaptures = possibleCaptures.stream()
                    .filter(capture -> capture.getOriginAction().direction() == action.direction())
                    .toList();
            if (possibleCaptures.isEmpty()) {
                throw new IllegalActionException();
            } else if (possibleCaptures.size() == 1) {
                newState = possibleCaptures.get(0);
                newState.setPlayer1Turn(!newState.isPlayer1Turn());
            } else {
                newState = tryCaptureWith(
                        piece,
                        possibleCaptureActions[action.direction().ordinal()],
                        state,
                        false
                ).value2().get(0);
                if (captureWithPiece(piece, newState).isEmpty()) {
                    newState.setPlayer1Turn(!newState.isPlayer1Turn());
                }
            }
        }
        return newState;
    }

    private int getPiecesScore(List<Piece> pieces) {
        return pieces.stream().mapToInt(Piece::getValue).sum();
    }

    public int evaluate(State state) {
        return getPiecesScore(state.getWhitePieces()) - getPiecesScore(state.getBlackPieces());
    }

    public boolean isFinal(State state) {
        return state.getWhitePieces().isEmpty() || state.getBlackPieces().isEmpty() || getChildren(state).isEmpty();
    }
}
