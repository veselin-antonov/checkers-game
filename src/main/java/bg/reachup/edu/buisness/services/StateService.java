package bg.reachup.edu.buisness.services;

import bg.reachup.edu.buisness.Pair;
import bg.reachup.edu.buisness.exceptions.state.IllegalActionException;
import bg.reachup.edu.buisness.exceptions.state.NoPieceAtCoordinatesException;
import bg.reachup.edu.buisness.exceptions.state.OpponentPieceException;
import bg.reachup.edu.data.entities.*;
import bg.reachup.edu.data.repositories.StateRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;

@Service
public class StateService {
    private final StateRepository repository;

    @Autowired
    public StateService(StateRepository repository) {
        this.repository = repository;
    }

    public void updateState(State toUpdate, State newState) {
        repository.findById(toUpdate.getId());
        toUpdate.setBoard(newState.getBoard());
        toUpdate.setPlayer1Turn(newState.isPlayer1Turn());
        toUpdate.setFinished(newState.isFinished());
        repository.save(toUpdate);
    }

    public List<State> getChildren(State state, String executor) {
        List<State> children = state.getChildren();
        if (children != null) {
            return children;
        }
        List<State> newChildren = new LinkedList<>();
        List<Piece> pieces = state.isPlayer1Turn() ? state.getWhitePieces() : state.getBlackPieces();
        pieces.forEach(piece -> newChildren.addAll(captureWithPiece(piece, state, executor)));
        newChildren.removeIf(Objects::isNull);
        if (newChildren.isEmpty()) {
            pieces.forEach(piece -> newChildren.addAll(movePiece(piece, state, executor)));
        }
        newChildren.removeIf(Objects::isNull);
        state.setChildren(newChildren);
        return newChildren;
    }

    /*
     * Record describing a move action. Contains the information, needed to perform the action:
     * - the direction in which the piece will be moved
     * - the offset by which the piece will be moved
     * - the predicate, testing if the move is possible.
     * */
    private record MoveAction(
            Direction moveDirection,
            Coordinates positionOffset,
            Predicate<Piece> predicate
    ) {
    }

    /*
     * Array consisting of all the possible ways to move a piece in the game
     * The elements are sorted by their ordinal value, so that every element's
     * ordinal value matches their index in the array, giving you direct access
     * when searching by direction.
     * */
    private final MoveAction[] possibleMoveActions = {
            new MoveAction(
                    Direction.UP_LEFT,
                    new Coordinates(-1, -1),
                    Piece::isWhite
            ),
            new MoveAction(
                    Direction.UP_RIGHT,
                    new Coordinates(-1, 1),
                    Piece::isWhite
            ),
            new MoveAction(
                    Direction.DOWN_LEFT,
                    new Coordinates(1, -1),
                    Piece::isBlack
            ),
            new MoveAction(
                    Direction.DOWN_RIGHT,
                    new Coordinates(1, 1),
                    Piece::isBlack
            )
    };

    /*
     * Generates a list of the states generated by the tryMove() method for each of the possible move actions.
     * */
    private List<State> movePiece(Piece piece, State state, String executor) {
        List<State> newStates = new LinkedList<>();
        for (MoveAction moveAction : possibleMoveActions) {
            tryMove(piece, moveAction, state, executor).ifPresent(newStates::add);
        }
        return newStates;
    }

    /*
     * The actual logic of moving a piece.
     * The method generates the new coordinates when the given offset is applied and then checks if these coordinates are valid:
     * - inside the board
     * - the new position is empty
     * - the piece type is allowed to move in that direction
     * - the given predicate returns true for the given piece.
     * */
    private Optional<State> tryMove(Piece piece, MoveAction action, State state, String executor) {
        Coordinates positionOffset = action.positionOffset;
        Predicate<Piece> predicate = action.predicate;

        Coordinates newCoordinates = piece.getCoordinates().modified(positionOffset.row(), positionOffset.column());
        if ((piece.isQueen() || predicate.test(piece))
                && state.getBoard().isWithin(newCoordinates)
                && state.getBoard().isFree(newCoordinates)
        ) {
            Board newBoard = state.getBoard().movePiece(piece.getCoordinates(), newCoordinates);
            return Optional.of(new State(
                    newBoard,
                    !state.isPlayer1Turn(),
                    new Action(
                            ActionType.MOVE,
                            action.moveDirection(),
                            piece.getCoordinates(),
                            executor
                    )
            ));
        }
        return Optional.empty();
    }

    /*
     * Record describing a capture action. Contains the information, needed to perform the action:
     * the direction in which the piece will be capturing
     * the offset to calculate the position of the opponent piece
     * the offset by which the piece will be moved
     * the predicate, testing if the capture is possible.
     * */
    private record CaptureAction(
            Direction captureDirection,
            Coordinates opponentOffset,
            Coordinates newPositionOffset,
            Predicate<Piece> predicate
    ) {
    }

    /*
     * Array consisting of all the possible ways to capture a piece in the game.
     * The elements are sorted by their ordinal value, so that every element's
     * ordinal value matches their index in the array, giving you direct access
     * when searching by direction.
     */
    private final CaptureAction[] possibleCaptureActions = {
            new CaptureAction(
                    Direction.UP_LEFT,
                    new Coordinates(-1, -1),
                    new Coordinates(-2, -2),
                    Piece::isWhite
            ),
            new CaptureAction(
                    Direction.UP_RIGHT,
                    new Coordinates(-1, 1),
                    new Coordinates(-2, 2),
                    Piece::isWhite
            ),
            new CaptureAction(
                    Direction.DOWN_LEFT,
                    new Coordinates(1, -1),
                    new Coordinates(2, -2),
                    Piece::isBlack
            ),
            new CaptureAction(
                    Direction.DOWN_RIGHT,
                    new Coordinates(1, 1),
                    new Coordinates(2, 2),
                    Piece::isBlack
            )
    };

    /*
     * Generates the states for capturing in all possible directions with the specified piece.
     * A list of the states with the largest capture streak are returned.
     */
    private List<State> captureWithPiece(Piece piece, State state, String executor) {
        List<Pair<Integer, List<State>>> biggestCaptures = new LinkedList<>();
        for (CaptureAction captureAction : possibleCaptureActions) {
            Pair<Integer, List<State>> captureStates = tryCaptureWith(piece, captureAction, state, executor, true);
            if (!captureStates.value2().isEmpty()) {
                biggestCaptures.add(captureStates);
            }
        }
        if (biggestCaptures.isEmpty()) {
            return List.of();
        }
        int maxCaptureStreak = biggestCaptures.stream()
                .mapToInt(Pair::value1)
                .max()
                .orElse(-1);
        return biggestCaptures.stream()
                .filter(pair -> pair.value1() == maxCaptureStreak)
                .map(Pair::value2)
                .flatMap(List::stream)
                .toList();
    }

    /*
     * Finds the state/states with the largest capture streak in the given direction. The method returns a
     * pair consisting of the number of consecutive captures and the corresponding list of states with
     * such streak. All the states are put in a stream, and collected in a TreeMap grouped by their capture
     * streak. The last entry (states with the largest streak) is returned as a pair object.
     */
    private Pair<Integer, List<State>> tryCaptureWith(
            Piece piece,
            CaptureAction action,
            State state,
            String executor,
            boolean chainCapture
    ) {
        Board board = state.getBoard();
        Coordinates opponentOffset = action.opponentOffset;
        Coordinates newPositionOffset = action.newPositionOffset;
        Predicate<Piece> predicate = action.predicate;

        Coordinates oldPos = piece.getCoordinates();
        Coordinates opponentPos = oldPos.modified(opponentOffset.row(), opponentOffset.column());
        Coordinates newPos = oldPos.modified(newPositionOffset.row(), newPositionOffset.column());

        if ((!predicate.test(piece) && !piece.isQueen())
                || !board.isWithin(newPos)
                || !board.isFree(newPos)
        ) {
            return new Pair<>(state.getCaptureStreak(), List.of());
        }
        Optional<Piece> toCapture = board.getAt(opponentPos);
        if (toCapture.isEmpty() || !toCapture.get().isOpponent(piece)) {
            return new Pair<>(state.getCaptureStreak(), List.of());
        }
        Board newBoard = board.movePiece(oldPos, newPos);
        newBoard.removeAt(toCapture.get().getCoordinates());
        State newState = new State(
                newBoard,
                state.isPlayer1Turn(),
                newBoard.getAt(newPos).get(),
                state.getCaptureStreak() + 1,
                state.getCaptureStreak() > 0 && piece.equals(state.getAttacker()) ?
                        state.getOriginAction() :
                        new Action(ActionType.CAPTURE, action.captureDirection(), oldPos, executor)
        );

        if (!chainCapture) {
            return new Pair<>(newState.getCaptureStreak(), List.of(newState));
        }

        TreeMap<Integer, List<State>> bestCaptureStreakStates = captureWithPiece(newState.getAttacker(), newState, executor).stream()
                .collect(Collectors.groupingBy(State::getCaptureStreak, TreeMap::new, Collectors.toList()));
        if (bestCaptureStreakStates.isEmpty()) {
            newState.setPlayer1Turn(!newState.isPlayer1Turn());
            return new Pair<>(newState.getCaptureStreak(), List.of(newState));
        } else {
            return new Pair<>(bestCaptureStreakStates.lastEntry().getKey(), bestCaptureStreakStates.lastEntry().getValue());
        }
    }

    /*
     * Returns the state of the game after executing the specified action.
     */
    public State executeAction(Action action, State state) {
        //Gets the piece to be moved, if there isn't one -> throws an exception
        Piece piece = state.getBoard().getAt(action.piecePosition()).orElseThrow(NoPieceAtCoordinatesException::new);


        //Throws an exception if the player is trying to move an opponent's piece
        if (state.isPlayer1Turn() != piece.isWhite()) {
            throw new OpponentPieceException();
        }
        //Gets all possible captures with the specified piece in the action parameter
        List<State> possibleCaptures = captureWithPiece(piece, state, action.executor());

        if ((possibleCaptures.isEmpty() && action.actionType() == ActionType.CAPTURE)
                || (!possibleCaptures.isEmpty() && action.actionType() == ActionType.MOVE)) {

            /*
             * Throws an exception if:
             * - the player tries to capture, but there is no possible capture with this piece
             * - the player tries to move, but he can capture with this piece
             */

            throw new IllegalActionException();
        } else if (possibleCaptures.isEmpty() && action.actionType() == ActionType.MOVE) {

            // Moves the piece and switches the player on turn

            MoveAction moveAction = possibleMoveActions[action.direction().ordinal()];
            State newState = tryMove(piece, moveAction, state, action.executor()).orElseThrow(IllegalActionException::new);
            newState.setPlayer1Turn(!state.isPlayer1Turn());
            return newState;
        }

        State newState;
        possibleCaptures = possibleCaptures
                .stream()
                .filter(capture -> capture.getOriginAction().direction() == action.direction())
                .toList();
        if (possibleCaptures.isEmpty()) {
            throw new IllegalActionException();
        }
        if (possibleCaptures.size() == 1) {
            /*
             * If there is only one possible way to capture with this piece,
             * the final state after all captures is returned
             * and the player on turn is switched
             */
            newState = possibleCaptures.get(0);
            newState.setPlayer1Turn(!state.isPlayer1Turn());
        } else {
            // Captures in the specified direction
            newState = tryCaptureWith(
                    piece,
                    possibleCaptureActions[action.direction().ordinal()],
                    state,
                    action.executor(),
                    false
            ).value2().get(0);

            //If the player can still capture, he stays on turn, otherwise -> the player on turn is switched
            boolean canStillCapture = !captureWithPiece(newState.getAttacker(), newState, action.executor()).isEmpty();
            newState.setPlayer1Turn(canStillCapture ? state.isPlayer1Turn() : !state.isPlayer1Turn());
        }
        return newState;
    }

    private int getPiecesScore(List<Piece> pieces) {
        return pieces.stream().mapToInt(Piece::getValue).sum();
    }

    public int evaluate(State state) {
        return getPiecesScore(state.getWhitePieces()) - getPiecesScore(state.getBlackPieces());
    }

    public boolean isFinal(State state) {
        return state.getWhitePieces().isEmpty() || state.getBlackPieces().isEmpty() || getChildren(state, null).isEmpty();
    }
}
